Index: src/main/java/com/example/solarSystem/SolarSystemApp.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.solarSystem;\r\n\r\nimport com.example.demo.NthDimension;\r\nimport javafx.animation.AnimationTimer;\r\nimport javafx.application.Application;\r\nimport javafx.geometry.Point3D;\r\nimport javafx.scene.*;\r\nimport javafx.scene.control.Button;\r\nimport javafx.scene.input.KeyCode;\r\nimport javafx.scene.input.ScrollEvent;\r\nimport javafx.scene.layout.StackPane;\r\nimport javafx.scene.layout.VBox;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.paint.PhongMaterial;\r\nimport javafx.scene.shape.Sphere;\r\nimport javafx.scene.transform.Rotate;\r\nimport javafx.stage.Stage;\r\nimport javafx.scene.shape.Cylinder;\r\n\r\n\r\n\r\nimport java.util.*;\r\nimport java.util.function.BiFunction;\r\n\r\npublic class SolarSystemApp extends Application {\r\n\r\n    private static final int SCALE = 250000;\r\n    private final List<Sphere> planetSpheres = new ArrayList<>();\r\n    private List<CelestialBody> bodies;\r\n    private double[] currentState;\r\n    private BiFunction<Double, double[], double[]> ode;\r\n\r\n    private double anchorX, anchorY;\r\n    private double anchorAngleX = 45;\r\n    private double anchorAngleY = 0;\r\n\r\n    private final Group orbitRingGroup = new Group();\r\n    private boolean orbitsVisible = true;\r\n\r\n\r\n    private final Map<KeyCode, Double> velocities = new HashMap<>();\r\n    private final Set<KeyCode> activeKeys = new HashSet<>();\r\n    @Override\r\n    public void start(Stage primaryStage) {\r\n        bodies = DataLoader.loadBodiesFromCSV(\"src/main/java/com/example/solarSystem/IC.csv\");\r\n        if (bodies == null || bodies.isEmpty()) {\r\n            System.err.println(\"Failed to load celestial bodies!\");\r\n            return;\r\n        }\r\n\r\n        CelestialBody earth = bodies.stream().filter(b -> b.getName().equalsIgnoreCase(\"earth\")).findFirst().orElse(null);\r\n        CelestialBody moon = bodies.stream().filter(b -> b.getName().equalsIgnoreCase(\"moon\")).findFirst().orElse(null);\r\n\r\n        if (earth != null && moon != null) {\r\n\r\n            double G = 6.67430e-20; // km^3 / kg / s^2\r\n            double earthMass = 5.972e24; // kg\r\n            double earthRadius = getScaledRadius(\"earth\") * SCALE;\r\n            double moonRadius = getScaledRadius(\"moon\") * SCALE;\r\n\r\n\r\n\r\n\r\n            // --- PHYSICS VALUES ---\r\n            double moonPhysicsDistance = 384_400; // km (real physics orbital radius)\r\n            double moonSpeed = Math.sqrt(G * earthMass / moonPhysicsDistance); // ~1.022 km/s\r\n\r\n            double visualBuffer = 8 * SCALE;\r\n\r\n            double boostedDistance = moonPhysicsDistance + 20 * SCALE;\r\n            Vector3D r = new Vector3D(moonPhysicsDistance, 0, 0);\r\n            Vector3D moonPhysicsPos = earth.getPosition().add(r);\r\n            Vector3D tangential = new Vector3D(0, 0, 1);\r\n            Vector3D orbitalVel = tangential.scale(moonSpeed);\r\n            Vector3D moonPhysicsVel = earth.getVelocity().add(orbitalVel);\r\n            moon.setPosition(moonPhysicsPos);\r\n            moon.setVelocity(moonPhysicsVel);\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n        double[] state0 = StateUtils.extractStateVector(bodies);\r\n        System.out.println(\"Earth pos: \" + earth.getPosition());\r\n        System.out.println(\"Moon pos: \" + moon.getPosition());\r\n        System.out.println(\"Distance: \" + earth.getPosition().subtract(moon.getPosition()).magnitude());\r\n\r\n\r\n        state0[3] = 0; state0[4] = 0; state0[5] = 0;\r\n\r\n        currentState = state0.clone();\r\n\r\n\r\n        ode = SolarSystemODE.generateODE(bodies);\r\n        currentState = state0.clone();\r\n\r\n        Group root = new Group();\r\n        SubScene subScene = new SubScene(root, 1000, 800, true, SceneAntialiasing.BALANCED);\r\n        subScene.setFill(Color.BLACK);\r\n\r\n        PerspectiveCamera camera = new PerspectiveCamera(true);\r\n        camera.setNearClip(0.1);\r\n        camera.setFarClip(100000);\r\n        camera.setTranslateX(-1362.1);\r\n        camera.setTranslateY(-5555.7);\r\n        camera.setTranslateZ(-11820.0);\r\n        Group cameraX = new Group(camera);\r\n        Group cameraY = new Group(cameraX);\r\n        cameraX.setRotationAxis(Rotate.X_AXIS);\r\n        cameraX.setRotate(-26.3);\r\n        cameraY.setRotationAxis(Rotate.Y_AXIS);\r\n        cameraY.setRotate(6.2);\r\n        root.getChildren().add(cameraY);\r\n\r\n        subScene.setCamera(camera);\r\n\r\n        PointLight light = new PointLight(Color.WHITE);\r\n        light.setTranslateY(-1000);\r\n        light.setTranslateZ(-500);\r\n        root.getChildren().addAll(light, new AmbientLight(Color.color(0.3, 0.3, 0.3)));\r\n\r\n\r\n        orbitRingGroup.getChildren().clear();\r\n\r\n\r\n        for (int i = 0; i < bodies.size(); i++) {\r\n            CelestialBody body = bodies.get(i);\r\n            Sphere sphere = new Sphere(getScaledRadius(body.getName()));\r\n            String name = body.getName().toLowerCase();\r\n\r\n\r\n            double visualScale = SCALE;\r\n            if (!INNER_PLANETS.contains(name) && !name.equals(\"moon\")) {\r\n                visualScale = SCALE * 4.5;\r\n            }\r\n\r\n\r\n            if (!name.equals(\"sun\") && !name.equals(\"moon\") && !name.equals(\"titan\")) {\r\n                double radius = body.getPosition().magnitude() / visualScale;\r\n                int segments = 200;\r\n\r\n                double dotRadius = 2.5;\r\n                double dotHeight = 1.0;\r\n\r\n                Group ring = new Group();\r\n                for (int j = 0; j < segments; j++) {\r\n                    double angle = 2 * Math.PI * j / segments;\r\n                    double x = radius * Math.cos(angle);\r\n                    double z = radius * Math.sin(angle);\r\n\r\n                    Cylinder dot = new Cylinder(dotRadius, dotHeight);\r\n                    dot.setMaterial(new PhongMaterial(Color.WHITE));\r\n                    dot.setRotationAxis(Rotate.X_AXIS);\r\n                    dot.setRotate(90);\r\n                    dot.setTranslateX(x);\r\n                    dot.setTranslateZ(z);\r\n\r\n                    ring.getChildren().add(dot);\r\n                }\r\n                orbitRingGroup.getChildren().add(ring);\r\n            }\r\n\r\n\r\n\r\n            PhongMaterial mat = new PhongMaterial(getColorForBody(body.getName()));\r\n            sphere.setMaterial(mat);\r\n            Vector3D position = body.getPosition();\r\n            sphere.setTranslateX(position.x / visualScale);\r\n            sphere.setTranslateY(position.z / visualScale);\r\n            sphere.setTranslateZ(position.y / visualScale);\r\n\r\n            planetSpheres.add(sphere);\r\n            root.getChildren().add(sphere);\r\n        }\r\n        root.getChildren().add(orbitRingGroup);\r\n\r\n\r\n\r\n        VBox uiOverlay = new VBox(10);\r\n        uiOverlay.setTranslateX(20);\r\n        uiOverlay.setTranslateY(20);\r\n        uiOverlay.setPickOnBounds(false);\r\n\r\n        Button showPositionBtn = new Button(\"Show Camera Location\");\r\n        Button resetBtn = new Button(\"Reset Camera\");\r\n        Button toggleOrbitsBtn = new Button(\"Toggle Orbits\");\r\n        toggleOrbitsBtn.setOnAction(e -> {\r\n            orbitsVisible = !orbitsVisible;\r\n            orbitRingGroup.setVisible(orbitsVisible);\r\n        });\r\n\r\n        showPositionBtn.setOnAction(e -> {\r\n            System.out.printf(\"\uD83D\uDCF7 Camera: X=%.1f, Y=%.1f, Z=%.1f | rotX=%.1f, rotY=%.1f%n\",\r\n                    camera.getTranslateX(),\r\n                    camera.getTranslateY(),\r\n                    camera.getTranslateZ(),\r\n                    cameraX.getRotate(),\r\n                    cameraY.getRotate());\r\n        });\r\n\r\n        resetBtn.setOnAction(e -> {\r\n            camera.setTranslateX(-1362.1);\r\n            camera.setTranslateY(-5555.7);\r\n            camera.setTranslateZ(-11820.0);\r\n            cameraX.setRotate(-26.3);\r\n            cameraY.setRotate(6.2);\r\n        });\r\n\r\n        uiOverlay.getChildren().addAll(showPositionBtn, resetBtn, toggleOrbitsBtn);\r\n\r\n        StackPane stackPane = new StackPane();\r\n        stackPane.getChildren().addAll(subScene, uiOverlay);\r\n        Scene scene = new Scene(stackPane);\r\n\r\n        scene.setOnKeyPressed(e -> {\r\n            activeKeys.add(e.getCode());\r\n            scene.getRoot().requestFocus();\r\n        });\r\n        scene.setOnKeyReleased(e -> activeKeys.remove(e.getCode()));\r\n\r\n        AnimationTimer movementTimer = new AnimationTimer() {\r\n            private long lastTime = -1;\r\n\r\n            @Override\r\n            public void handle(long now) {\r\n                if (lastTime < 0) {\r\n                    lastTime = now;\r\n                    return;\r\n                }\r\n                double deltaTime = (now - lastTime) / 1_000_000_000.0; //in seconds\r\n                lastTime = now;\r\n\r\n                double moveSpeed = 3000.0;\r\n                double dx = 0, dy = 0, dz = 0;\r\n\r\n                if (activeKeys.contains(KeyCode.W)) dz += moveSpeed * deltaTime;\r\n                if (activeKeys.contains(KeyCode.S)) dz -= moveSpeed * deltaTime;\r\n                if (activeKeys.contains(KeyCode.A)) dx -= moveSpeed * deltaTime;\r\n                if (activeKeys.contains(KeyCode.D)) dx += moveSpeed * deltaTime;\r\n                if (activeKeys.contains(KeyCode.CONTROL)) dy -= moveSpeed * deltaTime;\r\n                if (activeKeys.contains(KeyCode.SPACE)) dy += moveSpeed * deltaTime;\r\n\r\n\r\n                Point3D forward = camera.localToParentTransformProperty()\r\n                        .get().deltaTransform(0, 0, 1).normalize();\r\n\r\n                Point3D right = camera.localToParentTransformProperty()\r\n                        .get().deltaTransform(1, 0, 0).normalize();\r\n\r\n                Point3D up = camera.localToParentTransformProperty()\r\n                        .get().deltaTransform(0, -1, 0).normalize();\r\n\r\n                camera.setTranslateX(camera.getTranslateX() + dx * right.getX() + dy * up.getX() + dz * forward.getX());\r\n                camera.setTranslateY(camera.getTranslateY() + dx * right.getY() + dy * up.getY() + dz * forward.getY());\r\n                camera.setTranslateZ(camera.getTranslateZ() + dx * right.getZ() + dy * up.getZ() + dz * forward.getZ());\r\n            }\r\n        };\r\n        movementTimer.start();\r\n\r\n\r\n        scene.setOnMousePressed(e -> {\r\n            anchorX = e.getSceneX();\r\n            anchorY = e.getSceneY();\r\n            anchorAngleX = cameraX.getRotate();\r\n            anchorAngleY = cameraY.getRotate();\r\n        });\r\n\r\n        scene.setOnMouseDragged(e -> {\r\n            double deltaX = e.getSceneX() - anchorX;\r\n            double deltaY = e.getSceneY() - anchorY;\r\n            cameraX.setRotate(anchorAngleX - deltaY * 0.09);\r\n            cameraY.setRotate(anchorAngleY + deltaX * 0.09);\r\n        });\r\n\r\n        scene.setOnScroll((ScrollEvent e) -> {\r\n            double zoomFactor = e.getDeltaY() * 0.1;\r\n\r\n\r\n            double pitch = Math.toRadians(cameraX.getRotate());\r\n            double yaw = Math.toRadians(cameraY.getRotate());\r\n\r\n            double dx = Math.sin(yaw) * Math.cos(pitch);\r\n            double dy = -Math.sin(pitch);\r\n            double dz = Math.cos(yaw) * Math.cos(pitch);\r\n\r\n\r\n            camera.setTranslateX(camera.getTranslateX() + dx * zoomFactor * 50);\r\n            camera.setTranslateY(camera.getTranslateY() + dy * zoomFactor * 50);\r\n            camera.setTranslateZ(camera.getTranslateZ() + dz * zoomFactor * 50);\r\n        });\r\n\r\n\r\n        scene.setOnMouseClicked(e -> {\r\n            if (e.getClickCount() == 2) {\r\n                System.out.printf(\"\uD83D\uDCF7 Camera: Z=%.0f, rotX=%.1f, rotY=%.1f%n\",\r\n                        camera.getTranslateZ(), cameraX.getRotate(), cameraY.getRotate());\r\n            }\r\n        });\r\n\r\n        primaryStage.setScene(scene);\r\n        primaryStage.setTitle(\"Solar System â€“ Mouse Controlled View\");\r\n        primaryStage.show();\r\n\r\n        orbitTimer.start();\r\n    }\r\n\r\n    final Set<String> INNER_PLANETS = Set.of(\"mercury\", \"venus\", \"earth\", \"mars\");\r\n    final long[] lastUpdate = {System.nanoTime()};\r\n\r\n    AnimationTimer orbitTimer = new AnimationTimer() {\r\n        @Override\r\n        public void handle(long now) {\r\n            double step = 1350; // simulate one hour per frame\r\n\r\n            currentState = NthDimension.rungeKutta4Step(ode, 0, currentState, step);\r\n            StateUtils.applyStateVector(currentState, bodies);\r\n\r\n            for (int i = 0; i < bodies.size(); i++) {\r\n                CelestialBody body = bodies.get(i);\r\n                Vector3D pos = body.getPosition();\r\n                String name = body.getName().toLowerCase();\r\n\r\n                double visualScale = SCALE;\r\n\r\n\r\n                if (!INNER_PLANETS.contains(name) && !name.equals(\"moon\")) {\r\n                    visualScale = SCALE * 4.5;\r\n                }\r\n\r\n                if (name.equals(\"moon\")) {\r\n                    Vector3D earthPos = bodies.stream()\r\n                            .filter(b -> b.getName().equalsIgnoreCase(\"earth\"))\r\n                            .findFirst()\r\n                            .map(CelestialBody::getPosition)\r\n                            .orElse(new Vector3D(0, 0, 0));\r\n\r\n                    Vector3D directionFromEarth = pos.subtract(earthPos).normalize();\r\n                    pos = pos.add(directionFromEarth.scale(15 * SCALE));  // visually push moon out from Earth\r\n                }\r\n\r\n                planetSpheres.get(i).setTranslateX(pos.x / visualScale);\r\n                planetSpheres.get(i).setTranslateY(pos.z / visualScale);\r\n                planetSpheres.get(i).setTranslateZ(pos.y / visualScale);\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n\r\n    private Color getColorForBody(String name) {\r\n        return switch (name.toLowerCase()) {\r\n            case \"sun\" -> Color.GOLD;\r\n            case \"mercury\" -> Color.SILVER;\r\n            case \"venus\" -> Color.BURLYWOOD;\r\n            case \"earth\" -> Color.BLUE;\r\n            case \"moon\" -> Color.LIGHTGRAY;\r\n            case \"mars\" -> Color.RED;\r\n            case \"jupiter\" -> Color.ORANGE;\r\n            case \"saturn\" -> Color.BEIGE;\r\n            case \"titan\" -> Color.DARKKHAKI;\r\n            case \"uranus\" -> Color.AQUA;\r\n            case \"neptune\" -> Color.DARKBLUE;\r\n            default -> Color.WHITE;\r\n        };\r\n    }\r\n\r\n    private double getScaledRadius(String name) {\r\n            // * Sizes have been edited to make them as stable as possible.\r\n            return switch (name.toLowerCase()) {\r\n                case \"sun\" -> 150.65;\r\n                case \"mercury\" -> 4.0;\r\n                case \"venus\" -> 9.0;\r\n                case \"earth\" -> 10.0;\r\n                case \"moon\" -> 2.5;\r\n                case \"mars\" -> 5.5;\r\n                case \"jupiter\" -> 70.0;\r\n                case \"saturn\" -> 60.0;\r\n                case \"titan\" -> 4.0;\r\n                case \"uranus\" -> 26.0;\r\n                case \"neptune\" -> 23.0;\r\n                default -> 5.0;\r\n            };\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n    public static void main(String[] args) {\r\n        launch(args);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/example/solarSystem/SolarSystemApp.java b/src/main/java/com/example/solarSystem/SolarSystemApp.java
--- a/src/main/java/com/example/solarSystem/SolarSystemApp.java	(revision 7080f3e1f0b104fbdb5a2abaf7f7a1b83f04f3b2)
+++ b/src/main/java/com/example/solarSystem/SolarSystemApp.java	(date 1746521934836)
@@ -347,6 +347,20 @@
         }
     };
 
+    private double getScaledOrbitRadius(String name) {
+        return switch (name.toLowerCase()) {
+            case "mercury" -> 57.9e6 / SCALE;
+            case "venus"   -> 108.2e6 / SCALE;
+            case "earth"   -> 149.6e6 / SCALE;
+            case "mars"    -> 227.9e6 / SCALE;
+            case "jupiter" -> 778.3e6 / SCALE;
+            case "saturn"  -> 1427.0e6 / SCALE;
+            case "uranus"  -> 2871.0e6 / SCALE;
+            case "neptune" -> 4497.1e6 / SCALE;
+            default        -> -1; // For moon, titan, etc.
+        };
+    }
+
 
 
     private Color getColorForBody(String name) {
