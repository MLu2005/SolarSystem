Index: src/main/java/com/example/demo/Controller.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.demo;\r\nimport javafx.application.Platform;\r\nimport javafx.scene.control.*;\r\n\r\nimport java.util.Arrays;\r\nimport javafx.beans.binding.DoubleBinding;\r\nimport javafx.fxml.FXML;\r\nimport javafx.scene.layout.AnchorPane;\r\n\r\n\r\nimport java.util.function.BiFunction;\r\n\r\n\r\npublic class Controller {\r\n\r\n    @FXML\r\n    private AnchorPane root;\r\n    @FXML\r\n    private AnchorPane sun;\r\n    @FXML\r\n    private AnchorPane venus;\r\n    @FXML\r\n    private AnchorPane mercury;\r\n    @FXML\r\n    private AnchorPane earth;\r\n    @FXML\r\n    private AnchorPane mars;\r\n    @FXML\r\n    private AnchorPane jupiter;\r\n    @FXML\r\n    private AnchorPane saturn;\r\n\r\n\r\n    private void bindPlanetPositions() {\r\n\r\n\r\n        DoubleBinding sunLayoutX = root.widthProperty().multiply(0.1);\r\n        sun.layoutXProperty().bind(sunLayoutX);\r\n        sun.layoutYProperty().bind(root.heightProperty().multiply(0.1));\r\n\r\n        DoubleBinding venusLayoutX = root.widthProperty().multiply(0.2);\r\n        venus.layoutXProperty().bind(venusLayoutX);\r\n        venus.layoutYProperty().bind(root.heightProperty().multiply(0.2));\r\n\r\n        DoubleBinding mercuryLayoutX = root.widthProperty().multiply(0.3);\r\n        mercury.layoutXProperty().bind(mercuryLayoutX);\r\n        mercury.layoutYProperty().bind(root.heightProperty().multiply(0.3));\r\n\r\n        DoubleBinding earthLayoutX = root.widthProperty().multiply(0.4);\r\n        earth.layoutXProperty().bind(earthLayoutX);\r\n        earth.layoutYProperty().bind(root.heightProperty().multiply(0.4));\r\n\r\n        DoubleBinding marsLayoutX = root.widthProperty().multiply(0.5);\r\n        mars.layoutXProperty().bind(marsLayoutX);\r\n        mars.layoutYProperty().bind(root.heightProperty().multiply(0.5));\r\n\r\n        DoubleBinding jupiterLayoutX = root.widthProperty().multiply(0.6);\r\n        jupiter.layoutXProperty().bind(jupiterLayoutX);\r\n        jupiter.layoutYProperty().bind(root.heightProperty().multiply(0.6));\r\n\r\n        DoubleBinding saturnLayoutX = root.widthProperty().multiply(0.7);\r\n        saturn.layoutXProperty().bind(saturnLayoutX);\r\n        saturn.layoutYProperty().bind(root.heightProperty().multiply(0.7));\r\n    }\r\n\r\n    @FXML\r\n    private TextField  stepSizeInput;\r\n\r\n    @FXML\r\n    private TextField  stepsInput;\r\n\r\n    @FXML\r\n    private TextField initialConditionsInput;\r\n    @FXML\r\n    private TextArea equationInput;\r\n\r\n    @FXML\r\n    private TextField variablesInput;\r\n\r\n    @FXML\r\n    private ListView<String> resultListView;\r\n\r\n    @FXML\r\n    private Button solveButton;\r\n\r\n    @FXML\r\n    private RadioButton rk4MethodRadio;\r\n    @FXML\r\n    private RadioButton eulerMethodRadio;\r\n\r\n    private ToggleGroup toggleGroup;\r\n\r\n    @FXML\r\n    public void initialize() {\r\n        toggleGroup = new ToggleGroup();\r\n        eulerMethodRadio.setToggleGroup(toggleGroup);\r\n        rk4MethodRadio.setToggleGroup(toggleGroup);\r\n\r\n        // * Setting eulermethod class as default\r\n        eulerMethodRadio.setSelected(true);\r\n\r\n\r\n        eulerMethodRadio.setOnAction(event -> System.out.println(\"Euler method selected\"));\r\n        rk4MethodRadio.setOnAction(event -> System.out.println(\"Runge-Kutta 4 selected\"));\r\n\r\n\r\n        solveButton.setOnAction(e -> solveODE());\r\n    }\r\n\r\n    private void solveODE() {\r\n        try {\r\n            // * Var(x0) represents the independent variable it's set to zero by default but the user can explicitly put it as a different number.\r\n            // * and i parsed them because they're initially strings in the GUI just to make my life easier.\r\n            double x0 = Double.parseDouble(initialConditionsInput.getText().split(\",\")[0].trim());\r\n            double stepSize = Double.parseDouble(stepSizeInput.getText().trim());\r\n            int steps = Integer.parseInt(stepsInput.getText().trim());\r\n\r\n            String[] equations = equationInput.getText().split(\"\\n\");\r\n            String[] variables = variablesInput.getText().split(\",\");\r\n\r\n            for (int i = 0; i < variables.length; i++) {\r\n                variables[i] = variables[i].trim();\r\n            }\r\n\r\n            if (variables.length == 0 || variables[0].isEmpty()) {\r\n                System.out.println(\"??, Forgot to input the variables.\");\r\n            }\r\n\r\n            /* The part below is mainly focused on how the GUI is able to recieve multiple equations at the same time.\r\n            Basically, this function --> ODEUtility.setEquations(equations, variables)\r\n            And this function --> BiFunction<Double, double[], double[]> odeFunction = ODEUtility.textToFunction()\r\n\r\n            they simultaneously convert the user input from the equationInput[textArea] into a function that can work on multiple ODES by storing\r\n            them in the string array of equations variables which then splits them by lines and extracts the variables\r\n            from (variablesInput)[textField] by splitting the commas then it gets stored in equations[].\r\n\r\n             */\r\n\r\n            ODEUtility.setEquations(equations, variables); //ODEUTILITY CLASS\r\n            BiFunction<Double, double[], double[]> odeFunction = ODEUtility.textToFunction(); //ODEUTILITY CLASS\r\n            int stateSize = variables.length;\r\n            double[] initialState = new double[stateSize];\r\n\r\n\r\n            String[] initialValues = initialConditionsInput.getText().split(\",\");\r\n\r\n\r\n            // *  checking if the initial conditions match the number of state variables (EXCLUDING X0)!\r\n            if (initialValues.length != stateSize + 1) {\r\n                System.out.println(\"initial conditions do not match the number of variables.\");\r\n            }\r\n\r\n\r\n\r\n            for (int i = 1; i < initialValues.length; i++) {\r\n                initialState[i - 1] = Double.parseDouble(initialValues[i].trim());\r\n            }\r\n\r\n            // * cool radiobuttons to choose from higher dimension and first dimension can be applied by the user.\r\n            double[][] result;\r\n            if (eulerMethodRadio.isSelected()) {\r\n                System.out.println(\"You're using Euler Method\");\r\n                result = NthDimension.eulerNth(odeFunction::apply, x0, initialState, stepSize, steps);\r\n            } else {\r\n                System.out.println(\"You're using Runge-Kutta 4 Method\");\r\n                result = NthDimension.rungeKutta4(odeFunction, x0, initialState, stepSize, steps);\r\n            }\r\n\r\n\r\n\r\n            // * the part below is responsible for displaying the results in the viewlist\r\n            // * making the headrows for the variables, representing the independent variable, and loops through the dependent variable adding it to header :D\r\n            StringBuilder output = new StringBuilder(\"t\"); // t is our initial.\r\n            for (String var : variables) {\r\n                output.append(\"\\t\").append(var);\r\n            }\r\n            output.append(\"\\n\");\r\n\r\n            Platform.runLater(() -> {\r\n                resultListView.getItems().clear();\r\n                resultListView.getItems().add(output.toString());\r\n\r\n                for (double[] row : result) {\r\n                    StringBuilder rowText = new StringBuilder(\"t = \" + row[0]);\r\n                    for (int i = 1; i < row.length; i++) {\r\n                        rowText.append(\", \").append(variables[i - 1]).append(\" = \").append(row[i]);\r\n                    }\r\n                    resultListView.getItems().add(rowText.toString());\r\n                }\r\n            });\r\n\r\n        } catch (NumberFormatException ex) {\r\n            fightError(\"???Your input is invalid, make sure you enter valid numbers.???\");\r\n        } catch (IllegalArgumentException ex) {\r\n            fightError(ex.getMessage());\r\n        } catch (Exception ex) {\r\n            ex.printStackTrace();\r\n            fightError(\"Unknown error?\" + ex.getMessage());\r\n        }\r\n    }\r\n\r\n    private void fightError(String message) {\r\n        System.err.println(message);\r\n        Platform.runLater(() -> {\r\n            resultListView.getItems().clear();\r\n            resultListView.getItems().add(message);\r\n        });\r\n    }\r\n   }
===================================================================
diff --git a/src/main/java/com/example/demo/Controller.java b/src/main/java/com/example/demo/Controller.java
--- a/src/main/java/com/example/demo/Controller.java	(revision 695ed4a14066ead0ce1b86b4813aa59b40e59322)
+++ b/src/main/java/com/example/demo/Controller.java	(date 1743455373106)
@@ -1,7 +1,6 @@
 package com.example.demo;
 import javafx.application.Platform;
 import javafx.scene.control.*;
-
 import java.util.Arrays;
 import javafx.beans.binding.DoubleBinding;
 import javafx.fxml.FXML;
Index: src/main/java/com/example/demo/NthDimension.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.demo;\r\n\r\nimport java.util.Arrays;\r\nimport java.util.function.BiFunction;\r\n\r\nimport static com.example.demo.ODEUtility.addVectors;\r\nimport static com.example.demo.ODEUtility.scaleVector;\r\n\r\npublic class NthDimension {\r\n\r\n    /**\r\n     * Euler's method for solving an N-dimensional system of ODEs.\r\n     * based partly on: https://www.youtube.com/watch?v=KYlPFptGDQA\r\n     *\r\n     * @param f        The system of ODEs represented as a function (x, Y) -> dYdx.\r\n     * @param x        Initial x value.\r\n     * @param y        Initial values of y as an array.\r\n     * @param stepSize Step size (h).\r\n     * @param steps    Number of steps to compute.\r\n     * @return A 2D array containing x values and corresponding Y values at each step.\r\n     */\r\n    public static double[][] eulerNth(BiFunction<Double, double[], double[]> f, double x, double[] y, double stepSize, int steps) {\r\n        int n = y.length;\r\n        double[][] values = new double[steps + 1][n + 1];\r\n\r\n        values[0][0] = x;\r\n\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            values[0][i + 1] = y[i];\r\n        }\r\n\r\n        for (int i = 0; i < steps; i++) {\r\n\r\n            double[] dydx = f.apply(x, y);\r\n\r\n\r\n            for (int k = 0; k < n; k++) {\r\n                y[k] += stepSize * dydx[k];\r\n            }\r\n\r\n            x += stepSize;\r\n\r\n\r\n            x = Math.round(x * 100.0) / 100.0;\r\n\r\n            values[i + 1][0] = x;\r\n\r\n            for (int j = 0; j < n; j++) {\r\n                values[i + 1][j + 1] = y[j];\r\n            }\r\n        }\r\n        return values;\r\n    }\r\n\r\n\r\n    /**\r\n     * RK4 solver with an optional stopping condition.\r\n     * Stops early if the condition evaluates to true.\r\n     */\r\n    public static double[][] rungeKutta4(\r\n            BiFunction<Double, double[], double[]> f,\r\n            double t0,\r\n            double[] y0,\r\n            double stepSize,\r\n            int maxSteps,\r\n            BiFunction<Double, double[], Boolean> stopCondition\r\n    ) {\r\n        int dim = y0.length;\r\n        double[][] valuePairs = new double[maxSteps][dim + 1]; // first column = time\r\n        double t = t0;\r\n        double[] y = Arrays.copyOf(y0, dim); // copy of initial state\r\n\r\n        for (int i = 0; i < maxSteps; i++) {\r\n            valuePairs[i][0] = t;\r\n            System.arraycopy(y, 0, valuePairs[i], 1, dim);\r\n\r\n\r\n            if (stopCondition != null && stopCondition.apply(t, y)) {\r\n                return Arrays.copyOf(valuePairs, i + 1);\r\n            }\r\n\r\n\r\n            double[] k1 = f.apply(t, y);\r\n            double[] k2 = f.apply(t + stepSize / 2.0, addVectors(y, scaleVector(k1, stepSize / 2.0)));\r\n            double[] k3 = f.apply(t + stepSize / 2.0, addVectors(y, scaleVector(k2, stepSize / 2.0)));\r\n            double[] k4 = f.apply(t + stepSize, addVectors(y, scaleVector(k3, stepSize)));\r\n\r\n\r\n            for (int j = 0; j < dim; j++) {\r\n                y[j] += (stepSize / 6.0) * (k1[j] + 2 * k2[j] + 2 * k3[j] + k4[j]);\r\n            }\r\n\r\n\r\n            t += stepSize;\r\n\r\n\r\n            t = Math.round(t * 100.0) / 100.0;\r\n        }\r\n\r\n        return valuePairs;\r\n    }\r\n\r\n    /**\r\n     * RK4 solver with a fixed number of steps (no stopping condition).\r\n     */\r\n    public static double[][] rungeKutta4(\r\n            BiFunction<Double, double[], double[]> f,\r\n            double t0,\r\n            double[] y0,\r\n            double stepSize,\r\n            int maxSteps\r\n    ) {\r\n        return rungeKutta4(f, t0, y0, stepSize, maxSteps, null);\r\n    }\r\n}\r\n
===================================================================
diff --git a/src/main/java/com/example/demo/NthDimension.java b/src/main/java/com/example/demo/NthDimension.java
--- a/src/main/java/com/example/demo/NthDimension.java	(revision 695ed4a14066ead0ce1b86b4813aa59b40e59322)
+++ b/src/main/java/com/example/demo/NthDimension.java	(date 1743455263155)
@@ -1,4 +1,4 @@
-package com.example.demo;
+package src.main.java.com.example.demo;
 
 import java.util.Arrays;
 import java.util.function.BiFunction;
